# Test Metrics Exporter Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-metrics-exporter
  namespace: monitoring
  labels:
    app: test-metrics-exporter
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test-metrics-exporter
  template:
    metadata:
      labels:
        app: test-metrics-exporter
      annotations:
        # Disable kubernetes auto-discovery to avoid duplicate scraping
        prometheus.io/scrape: "false"
    spec:
      containers:
        - name: test-metrics-exporter
          image: node:18-alpine
          imagePullPolicy: Always
          ports:
            - containerPort: 9091
          command: ["/bin/sh", "-c"]
          args:
            - |
              apk add --no-cache wget && \
              mkdir -p /app && cd /app && \
              cat > package.json << 'EOF'
              {"name":"test-metrics-exporter","version":"1.0.0","main":"server.js","dependencies":{"express":"^4.18.2"}}
              EOF
              cat > server.js << 'EOF'
              const express = require('express');
              const app = express();
              app.use(express.json());
              
              let testMetrics = {
                lastRun: null,
                summary: { total: 0, passed: 0, failed: 0, skipped: 0, coverage: 0 },
                services: {}
              };
              
              let sonarMetrics = {
                lastRun: null,
                bugs: 0,
                vulnerabilities: 0,
                codeSmells: 0,
                coverage: 0,
                duplications: 0,
                linesOfCode: 0
              };
              
              // Application metrics (login, requests, users)
              let appMetrics = {
                activeUsers: 0,
                totalLogins: 0,
                totalRequests: 0,
                requestsPerService: {},
                loginHistory: [],
                responseTimeAvg: 0
              };
              
              app.get('/health', (req, res) => res.json({ status: 'healthy' }));
              
              // Endpoint để nhận app metrics
              app.post('/api/app-metrics', (req, res) => {
                const data = req.body;
                if (data.activeUsers !== undefined) appMetrics.activeUsers = data.activeUsers;
                if (data.logins) appMetrics.totalLogins += data.logins;
                if (data.requests) appMetrics.totalRequests += data.requests;
                if (data.service && data.requests) {
                  appMetrics.requestsPerService[data.service] = (appMetrics.requestsPerService[data.service] || 0) + data.requests;
                }
                if (data.responseTime) appMetrics.responseTimeAvg = data.responseTime;
                res.json({ success: true, current: appMetrics });
              });
              
              // Reset metrics
              app.post('/api/app-metrics/reset', (req, res) => {
                appMetrics = { activeUsers: 0, totalLogins: 0, totalRequests: 0, requestsPerService: {}, loginHistory: [], responseTimeAvg: 0 };
                res.json({ success: true, message: 'Metrics reset' });
              });
              
              app.post('/api/report', (req, res) => {
                const data = req.body;
                testMetrics.lastRun = new Date().toISOString();
                if (data.service && data.results) {
                  testMetrics.services[data.service] = data.results;
                  let total = 0, passed = 0, failed = 0, skipped = 0;
                  Object.values(testMetrics.services).forEach(s => {
                    total += s.total || 0;
                    passed += s.passed || 0;
                    failed += s.failed || 0;
                    skipped += s.skipped || 0;
                  });
                  testMetrics.summary = { total, passed, failed, skipped, coverage: data.coverage || 0 };
                }
                res.json({ success: true });
              });
              
              app.post('/api/sonar', (req, res) => {
                const data = req.body;
                sonarMetrics = {
                  lastRun: data.timestamp || new Date().toISOString(),
                  bugs: parseInt(data.bugs) || 0,
                  vulnerabilities: parseInt(data.vulnerabilities) || 0,
                  codeSmells: parseInt(data.codeSmells) || 0,
                  coverage: parseFloat(data.coverage) || 0,
                  duplications: parseFloat(data.duplications) || 0,
                  linesOfCode: parseInt(data.linesOfCode) || 0
                };
                console.log('SonarCloud metrics updated:', sonarMetrics);
                res.json({ success: true });
              });
              
              // NEW: Endpoint to receive test results from GitHub Actions
              app.post('/api/test-results', (req, res) => {
                const data = req.body;
                console.log('Received test results:', JSON.stringify(data));
                
                // Update summary
                testMetrics.summary = {
                  total: parseInt(data.total) || 0,
                  passed: parseInt(data.passed) || 0,
                  failed: parseInt(data.failed) || 0,
                  skipped: parseInt(data.skipped) || 0,
                  coverage: parseFloat(data.coverage) || 0
                };
                testMetrics.lastRun = new Date().toISOString();
                
                // Update service-level metrics
                if (data.services) {
                  Object.keys(data.services).forEach(service => {
                    testMetrics.services[service] = {
                      total: data.services[service].total || 0,
                      passed: data.services[service].passed || 0,
                      failed: data.services[service].failed || 0
                    };
                  });
                }
                
                console.log('Test metrics updated:', testMetrics.summary);
                res.json({ success: true, summary: testMetrics.summary });
              });
              
              app.get('/metrics', (req, res) => {
                const s = testMetrics.summary;
                const passRate = s.total > 0 ? (s.passed / s.total * 100).toFixed(2) : 0;
                let metrics = '';
                
                // Test metrics
                metrics += '# HELP test_total Total number of tests\n# TYPE test_total gauge\ntest_total ' + s.total + '\n';
                metrics += '# HELP test_passed Number of passed tests\n# TYPE test_passed gauge\ntest_passed ' + s.passed + '\n';
                metrics += '# HELP test_failed Number of failed tests\n# TYPE test_failed gauge\ntest_failed ' + s.failed + '\n';
                metrics += '# HELP test_skipped Number of skipped tests\n# TYPE test_skipped gauge\ntest_skipped ' + s.skipped + '\n';
                metrics += '# HELP test_pass_rate Test pass rate percentage\n# TYPE test_pass_rate gauge\ntest_pass_rate ' + passRate + '\n';
                metrics += '# HELP test_coverage_percent Code coverage percentage\n# TYPE test_coverage_percent gauge\ntest_coverage_percent ' + s.coverage + '\n';
                
                // Service-level test metrics
                Object.entries(testMetrics.services).forEach(([svc, r]) => {
                  metrics += 'test_service_total{service="' + svc + '"} ' + (r.total || 0) + '\n';
                  metrics += 'test_service_passed{service="' + svc + '"} ' + (r.passed || 0) + '\n';
                  metrics += 'test_service_failed{service="' + svc + '"} ' + (r.failed || 0) + '\n';
                });
                
                // SonarCloud metrics
                metrics += '\n# HELP sonar_bugs Number of bugs from SonarCloud\n# TYPE sonar_bugs gauge\nsonar_bugs ' + sonarMetrics.bugs + '\n';
                metrics += '# HELP sonar_vulnerabilities Number of vulnerabilities from SonarCloud\n# TYPE sonar_vulnerabilities gauge\nsonar_vulnerabilities ' + sonarMetrics.vulnerabilities + '\n';
                metrics += '# HELP sonar_code_smells Number of code smells from SonarCloud\n# TYPE sonar_code_smells gauge\nsonar_code_smells ' + sonarMetrics.codeSmells + '\n';
                metrics += '# HELP sonar_coverage Code coverage percentage from SonarCloud\n# TYPE sonar_coverage gauge\nsonar_coverage ' + sonarMetrics.coverage + '\n';
                metrics += '# HELP sonar_duplications Duplicated lines percentage from SonarCloud\n# TYPE sonar_duplications gauge\nsonar_duplications ' + sonarMetrics.duplications + '\n';
                metrics += '# HELP sonar_lines_of_code Total lines of code from SonarCloud\n# TYPE sonar_lines_of_code gauge\nsonar_lines_of_code ' + sonarMetrics.linesOfCode + '\n';
                
                // Application metrics
                metrics += '\n# HELP app_active_users Number of currently active users\n# TYPE app_active_users gauge\napp_active_users ' + appMetrics.activeUsers + '\n';
                metrics += '# HELP app_total_logins Total number of logins\n# TYPE app_total_logins counter\napp_total_logins ' + appMetrics.totalLogins + '\n';
                metrics += '# HELP app_total_requests Total number of API requests\n# TYPE app_total_requests counter\napp_total_requests ' + appMetrics.totalRequests + '\n';
                metrics += '# HELP app_response_time_avg Average response time in ms\n# TYPE app_response_time_avg gauge\napp_response_time_avg ' + appMetrics.responseTimeAvg + '\n';
                
                // Requests per service
                Object.entries(appMetrics.requestsPerService).forEach(([svc, count]) => {
                  metrics += 'app_requests_per_service{service="' + svc + '"} ' + count + '\n';
                });
                
                res.set('Content-Type', 'text/plain');
                res.send(metrics);
              });
              
              app.listen(9091, () => console.log('Test metrics exporter running on port 9091'));
              EOF
              npm install && node server.js
          env:
            - name: PORT
              value: "9091"
            - name: NODE_ENV
              value: "production"
          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "128Mi"
              cpu: "100m"
          livenessProbe:
            httpGet:
              path: /health
              port: 9091
            initialDelaySeconds: 60
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /health
              port: 9091
            initialDelaySeconds: 30
            periodSeconds: 10

---
apiVersion: v1
kind: Service
metadata:
  name: test-metrics-exporter
  namespace: monitoring
  labels:
    app: test-metrics-exporter
    monitoring: enabled
spec:
  type: ClusterIP
  ports:
    - port: 9091
      targetPort: 9091
      name: metrics
  selector:
    app: test-metrics-exporter
