# Test Monitoring Workflow
# PURPOSE: Runs tests and exports results to Prometheus/Grafana monitoring dashboard
# NOTE: This is separate from ci-cd.yml which runs tests for CI purposes
# This workflow focuses on METRICS COLLECTION for the monitoring dashboard

name: Test & Monitor

on:
  # Only run on schedule and manual trigger to avoid duplication with ci-cd.yml
  schedule:
    # Run tests every 6 hours for monitoring
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      force_run:
        description: 'Force run even if ci-cd ran recently'
        required: false
        default: false
        type: boolean

env:
  NODE_ENV: test

jobs:
  test-auth:
    name: üîê Auth Service Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        working-directory: ./auth
        run: npm install
      
      - name: Create test reports directory
        run: mkdir -p test-reports
      
      - name: Run tests with coverage
        working-directory: ./auth
        run: |
          npm test -- --coverage --json --outputFile=../test-reports/auth-results.json || true
        env:
          SERVICE_NAME: auth
          MONGO_URI: mongodb://localhost:27017/test
          JWT_SECRET: test-secret
      
      - name: Create default result if missing
        run: |
          if [ ! -f test-reports/auth-results.json ]; then
            echo '{"numTotalTests":0,"numPassedTests":0,"numFailedTests":0,"numPendingTests":0,"success":false}' > test-reports/auth-results.json
          fi
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: auth-test-results
          path: test-reports/
          retention-days: 30

  test-order:
    name: üì¶ Order Service Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        working-directory: ./order
        run: npm install
      
      - name: Create test reports directory
        run: mkdir -p test-reports
      
      - name: Run tests with coverage
        working-directory: ./order
        run: |
          npm test -- --coverage --json --outputFile=../test-reports/order-results.json || true
        env:
          SERVICE_NAME: order
          MONGO_URI: mongodb://localhost:27017/test
          JWT_SECRET: test-secret
      
      - name: Create default result if missing
        run: |
          if [ ! -f test-reports/order-results.json ]; then
            echo '{"numTotalTests":0,"numPassedTests":0,"numFailedTests":0,"numPendingTests":0,"success":false}' > test-reports/order-results.json
          fi
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: order-test-results
          path: test-reports/
          retention-days: 30

  test-restaurant:
    name: üçî Restaurant Service Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        working-directory: ./restaurant
        run: npm install
      
      - name: Create test reports directory
        run: mkdir -p test-reports
      
      - name: Run tests with coverage
        working-directory: ./restaurant
        run: |
          npm test -- --coverage --json --outputFile=../test-reports/restaurant-results.json || true
        env:
          SERVICE_NAME: restaurant
          MONGO_URI: mongodb://localhost:27017/test
          JWT_SECRET: test-secret
      
      - name: Create default result if missing
        run: |
          if [ ! -f test-reports/restaurant-results.json ]; then
            echo '{"numTotalTests":0,"numPassedTests":0,"numFailedTests":0,"numPendingTests":0,"success":false}' > test-reports/restaurant-results.json
          fi
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: restaurant-test-results
          path: test-reports/
          retention-days: 30

  test-payment:
    name: üí≥ Payment Service Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        working-directory: ./payment-service
        run: npm install
      
      - name: Create test reports directory
        run: mkdir -p test-reports
      
      - name: Run tests with coverage
        working-directory: ./payment-service
        run: |
          npm test -- --coverage --json --outputFile=../test-reports/payment-results.json || true
        env:
          SERVICE_NAME: payment
          MONGO_URI: mongodb://localhost:27017/test
      
      - name: Create default result if missing
        run: |
          if [ ! -f test-reports/payment-results.json ]; then
            echo '{"numTotalTests":0,"numPassedTests":0,"numFailedTests":0,"numPendingTests":0,"success":false}' > test-reports/payment-results.json
          fi
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: payment-test-results
          path: test-reports/
          retention-days: 30

  test-notification:
    name: üîî Notification Service Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        working-directory: ./notification-service
        run: npm install
      
      - name: Create test reports directory
        run: mkdir -p test-reports
      
      - name: Run tests with coverage
        working-directory: ./notification-service
        run: |
          npm test -- --coverage --json --outputFile=../test-reports/notification-results.json || true
        env:
          SERVICE_NAME: notification
          MONGO_URI: mongodb://localhost:27017/test
      
      - name: Create default result if missing
        run: |
          if [ ! -f test-reports/notification-results.json ]; then
            echo '{"numTotalTests":0,"numPassedTests":0,"numFailedTests":0,"numPendingTests":0,"success":false}' > test-reports/notification-results.json
          fi
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: notification-test-results
          path: test-reports/
          retention-days: 30

  aggregate-results:
    name: üìä Aggregate Test Results
    needs: [test-auth, test-order, test-restaurant, test-payment, test-notification]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - uses: actions/checkout@v4
      
      - name: Create test reports directory
        run: mkdir -p test-reports
      
      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          path: test-reports
          merge-multiple: true
        continue-on-error: true
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Generate aggregated report
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          const reportsDir = './test-reports';
          const services = ['auth', 'order', 'restaurant', 'payment', 'notification'];
          
          // Ensure reports directory exists
          if (!fs.existsSync(reportsDir)) {
            fs.mkdirSync(reportsDir, { recursive: true });
          }
          
          let summary = {
            timestamp: new Date().toISOString(),
            total: 0,
            passed: 0,
            failed: 0,
            skipped: 0,
            coverage: 0,
            services: {}
          };
          
          let totalCoverage = 0;
          let coverageCount = 0;
          
          services.forEach(service => {
            const reportPath = path.join(reportsDir, `${service}-results.json`);
            const coveragePath = path.join(reportsDir, `${service}-coverage.json`);
            
            if (fs.existsSync(reportPath)) {
              try {
                const data = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
                
                // Try to get coverage from Jest report or coverage file
                let serviceCoverage = 0;
                if (data.coverageMap) {
                  const covSummary = data.coverageMap.total || {};
                  serviceCoverage = covSummary.lines?.pct || covSummary.statements?.pct || 0;
                }
                if (fs.existsSync(coveragePath)) {
                  try {
                    const covData = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));
                    serviceCoverage = covData.total?.lines?.pct || covData.total?.statements?.pct || serviceCoverage;
                  } catch (e) {}
                }
                
                summary.services[service] = {
                  total: data.numTotalTests || 0,
                  passed: data.numPassedTests || 0,
                  failed: data.numFailedTests || 0,
                  skipped: data.numPendingTests || 0,
                  coverage: serviceCoverage,
                  success: data.success
                };
                summary.total += data.numTotalTests || 0;
                summary.passed += data.numPassedTests || 0;
                summary.failed += data.numFailedTests || 0;
                summary.skipped += data.numPendingTests || 0;
                
                if (serviceCoverage > 0) {
                  totalCoverage += serviceCoverage;
                  coverageCount++;
                }
              } catch (e) {
                console.error(`Error parsing ${service} results:`, e.message);
                summary.services[service] = { total: 0, passed: 0, failed: 0, skipped: 0, coverage: 0, success: false, error: e.message };
              }
            } else {
              console.log(`No results found for ${service}`);
              summary.services[service] = { total: 0, passed: 0, failed: 0, skipped: 0, coverage: 0, success: false, error: 'No results file' };
            }
          });
          
          summary.passRate = summary.total > 0 
            ? ((summary.passed / summary.total) * 100).toFixed(2) 
            : '0.00';
          
          // Calculate average coverage
          summary.coverage = coverageCount > 0 ? (totalCoverage / coverageCount).toFixed(2) : 0;
          
          fs.writeFileSync(
            path.join(reportsDir, 'summary.json'),
            JSON.stringify(summary, null, 2)
          );
          
          console.log('‚ïê'.repeat(60));
          console.log('üìä TEST SUMMARY REPORT');
          console.log('‚ïê'.repeat(60));
          console.log(`Total Tests: ${summary.total}`);
          console.log(`Passed:      ${summary.passed} ‚úÖ`);
          console.log(`Failed:      ${summary.failed} ${summary.failed > 0 ? '‚ùå' : '‚úÖ'}`);
          console.log(`Skipped:     ${summary.skipped}`);
          console.log(`Pass Rate:   ${summary.passRate}%`);
          console.log('‚ïê'.repeat(60));
          console.log('');
          console.log('Per Service:');
          Object.entries(summary.services).forEach(([name, data]) => {
            const status = data.success ? '‚úÖ' : (data.error ? '‚ö†Ô∏è' : '‚ùå');
            console.log(`  ${name}: ${data.passed}/${data.total} passed ${status}`);
          });
          console.log('‚ïê'.repeat(60));
          EOF
      
      - name: Upload aggregated report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-summary
          path: test-reports/summary.json
          retention-days: 90
      
      - name: Create test badge
        id: badge
        if: always()
        run: |
          if [ -f test-reports/summary.json ]; then
            PASS_RATE=$(cat test-reports/summary.json | jq -r '.passRate')
            TOTAL=$(cat test-reports/summary.json | jq -r '.total')
            PASSED=$(cat test-reports/summary.json | jq -r '.passed')
          else
            PASS_RATE="0"
            TOTAL="0"
            PASSED="0"
          fi
          
          if [ "$PASS_RATE" = "null" ]; then PASS_RATE="0"; fi
          
          echo "Test pass rate: ${PASS_RATE}%"
          echo "PASS_RATE=${PASS_RATE}" >> $GITHUB_OUTPUT
      
      - name: Post to Slack (optional)
        if: failure() && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"‚ùå Test failures detected in ${{ github.repository }}! See: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}" \
            $SLACK_WEBHOOK_URL || echo "Slack notification skipped"
        continue-on-error: true

  publish-metrics:
    name: üìà Publish to Monitoring
    needs: aggregate-results
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Download summary
        uses: actions/download-artifact@v4
        with:
          name: test-summary
          path: ./
        continue-on-error: true
      
      - name: Send to monitoring (if available)
        env:
          METRICS_ENDPOINT: ${{ secrets.TEST_METRICS_URL }}
        run: |
          if [ -f summary.json ] && [ -n "$METRICS_ENDPOINT" ]; then
            echo "üìä Sending test results to monitoring..."
            cat summary.json
            
            # Send each service's results individually
            for service in auth order restaurant payment notification; do
              TOTAL=$(jq -r ".services.$service.total // 0" summary.json)
              PASSED=$(jq -r ".services.$service.passed // 0" summary.json)
              FAILED=$(jq -r ".services.$service.failed // 0" summary.json)
              SKIPPED=$(jq -r ".services.$service.skipped // 0" summary.json)
              
              echo "Sending $service: total=$TOTAL, passed=$PASSED, failed=$FAILED"
              curl -s -X POST "$METRICS_ENDPOINT/api/report" \
                -H "Content-Type: application/json" \
                -d "{\"service\":\"$service\",\"results\":{\"total\":$TOTAL,\"passed\":$PASSED,\"failed\":$FAILED,\"skipped\":$SKIPPED}}" || true
            done
            
            # Also send summary coverage
            COVERAGE=$(jq -r ".coverage // 0" summary.json)
            echo "Total coverage: $COVERAGE%"
            
            echo "‚úÖ Metrics sent successfully"
          else
            echo "‚ö†Ô∏è No metrics endpoint configured or no summary file, skipping..."
            echo "Summary file exists: $(test -f summary.json && echo 'yes' || echo 'no')"
            echo "METRICS_ENDPOINT set: $(test -n \"$METRICS_ENDPOINT\" && echo 'yes' || echo 'no')"
          fi
